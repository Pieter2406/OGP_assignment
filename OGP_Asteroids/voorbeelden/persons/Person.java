package persons;import java.math.BigInteger;import java.util.*;import java.lang.reflect.*;import ownings.*;import be.kuleuven.cs.som.annotate.*;/** * A class of persons involving a relation with things they own. *  * @invar   Each person must have proper ownings. *        | hasProperOwnings() *  * @version  2.0 * @author   Eric Steegmans */public class Person {	/**	 * Initialize this new person with no ownings.	 *	 * @post    This new person does not have any ownings yet.	 *        | new.getNbOwnings() == 0	 */	@Raw	public Person() {	}	/**	 * Check whether this person is terminated.	 */	@Basic	@Raw	public boolean isTerminated() {		return this.isTerminated;	}	/**	 * Terminate this person.	 *	 * @post    This person is terminated.	 *        | new.isTerminated()	 * @post    Each of the ownings of this person no longer has	 *          a owner.	 *        | for each owning in getAllOwnings():	 *        |	  (! (new owning).hasOwner())	 */	public void terminate() {		if (!isTerminated()) {			for (Ownable owning : getAllOwnings())				owning.unsetOwner();			this.isTerminated = true;		}	}	/**	 * Variable reflecting whether or not this person is terminated.	 */	private boolean isTerminated;	/**	 * Return the owning of this person at the given index.	 * 	 * @param   index	 *          The index of the owning to return.	 * @throws  IndexOutOfBoundsException	 *          The given index is not positive or it exceeds the	 *          number of ownings of this person.	 *        | (index < 1) || (index > getNbOwnings())	 */	@Basic	@Raw	public Ownable getOwningAt(int index) throws IndexOutOfBoundsException {		return ownings.get(index - 1);	}	/**	 * Return the number of ownings of this person.	 */	@Basic	@Raw	public int getNbOwnings() {		return ownings.size();	}	/**	 * Check whether this person can have the given owning	 * as one of its ownings.	 * 	 * @param   owning	 *          The owning to check.	 * @return  True if and only if the given owning is effective, and	 *          if that owning can have this person as its owner.	 *        | result ==	 *        |   (owning != null) &&	 *        |   owning.canHaveAsOwner(this)	 */	@Raw	public boolean canHaveAsOwning(Ownable owning) {		return (owning != null) && owning.canHaveAsOwner(this);	}	/**	 * Check whether this person can have the given owning	 * as one of its ownings at the given index.	 * 	 * @param   owning	 *          The owning to check.	 * @param   index	 *          The index to check.	 * @return  False if the given index is not positive or exceeds	 *          the number of ownings of this person + 1.	 *        | if ( (index < 1) || (index > getNbOwnings()+1) )	 *        |   then result == false	 *          Otherwise, false if this person cannot have the	 *          given owning as one of its ownings.	 *        | else if (! canHaveAsOwning(owning))	 *        |   then result == false	 *          Otherwise, true if and only if the given owning is	 *          not already registered at another index.	 *        | else result ==	 *        |   for each I in 1..getNbOwnings():	 *        |     ( (I == index) || (getOwningAt(I) != owning) )	 */	@Raw	public boolean canHaveAsOwningAt(Ownable owning, int index) {		if ((index < 1) || (index > getNbOwnings() + 1))			return false;		if (!canHaveAsOwning(owning))			return false;		for (int pos = 1; pos <= getNbOwnings(); pos++)			if ((pos != index) && (getOwningAt(pos) == owning))				return false;		return true;	}	/**	 * Check whether this person has a proper list of ownings.	 * 	 * @return  True if and only if this person can have each of its	 *          ownings at their index, and if each of these ownings	 *          references this person as their owner.	 *        | for each index in 1..getNbOwnings():	 *        |   canHaveAsOwningAt(getOwningAt(index),index) &&	 *        |   (getOwningAt(index).getOwner() == this)	 */	public boolean hasProperOwnings() {		for (int index = 1; index <= getNbOwnings(); index++) {			if (!canHaveAsOwningAt(getOwningAt(index), index))				return false;			if (getOwningAt(index).getOwner() != this)				return false;		}		return true;	}	/**	 * Check whether this person has the given owning as one of	 * its ownings.	 *	 * @param   owning	 *          The owning to check.	 * @return  True if and only if this person has the given owning	 *          as one of its ownings at some index.	 *        | result ==	 *        |   for some index in 1..getNbOwnings():	 *        |     getOwningAt(index).equals(owning)	 */	@Raw	public boolean hasAsOwning(Ownable owning) {		return ownings.contains(owning);	}	/**	 * Return the index at which the given owning is registered	 * in the list of ownings for this person.	 *  	 * @param  owning	 *         The owning to search for.	 * @return If this person has the given owning as one of its	 *         ownings, that owning is registered at the resulting	 *         index. Otherwise, the resulting value is -1.	 *       | if (hasAsOwning(owning))	 *       |    then getOwningAt(result) == owning	 *       |    else result == -1	 */	@Raw	public int getIndexOfOwning(Ownable owning) {		return ownings.indexOf(owning);	}	/**	 * Return a list of all the ownings of this person.	 * 	 * @return  The size of the resulting list is equal to the number of	 *          ownings of this person.	 *        | result.size() == getNbOwnings()	 * @return  Each element in the resulting list is the same as the	 *          owning of this person at the corresponding index.	 *        | for each index in 0..result-size()-1 :	 *        |   result.get(index) == getOwningAt(index+1)	 */	public List<Ownable> getAllOwnings() {		return new ArrayList<Ownable>(ownings);	}	/**	 * Add the given owning at the end of the list of	 * ownings of this person.	 * 	 * @param   owning	 *          The owning to be added.	 * @pre     The given owning is effective and already references	 *          this person as its owner.	 *        | (owning != null) && (owning.getOwner() == this)	 * @pre     This person does not not yet have the given owning	 *          as one of its ownings.	 *        | ! hasAsOwning(owning)	 * @post    The number of ownings of this person is incremented	 *          by 1.	 *        | new.getNbOwnings() == getNbOwnings() + 1	 * @post    This person has the given owning as its new last	 *          owning.	 *        | new.getOwningAt(getNbOwnings()+1) == owning	 */	public void addAsOwning(@Raw Ownable owning) {		assert (owning != null) && (owning.getOwner() == this);		assert !hasAsOwning(owning);		ownings.add(owning);	}	/**	 * Remove the given owning from the ownings of this person.	 * 	 * @param   owning	 *          The owning to be removed.	 * @pre     The given owning is effective and does not have any	 *          owner.	 *        | (owning != null) && (owning.getOwner() == null)	 * @pre     This person has the given owning as one of	 *          its ownings.	 *        | hasAsOwning(owning)	 * @post    The number of ownings of this person is decremented	 *          by 1.	 *        | new.getNbOwnings() == getNbOwnings() - 1	 * @post    This person no longer has the given owning as	 *          one of its ownings.	 *        | (! new.hasAsOwning(owning))	 * @post    All ownings registered beyond the removed owning	 *          shift one position to the left.	 *        | for each index in getIndexOfOwning(owning)+1..getNbOwnings():	 *        |   new.getOwningAt(index-1) == getOwningAt(index) 	 */	@Raw	public void removeAsOwning(Ownable owning) {		assert (owning != null) && (owning.getOwner() == null);		assert (hasAsOwning(owning));		ownings.remove(owning);	}	/**	 * Variable referencing a list collecting all the ownings of	 * this person.	 * 	 * @invar   The referenced list is effective.	 *        | ownings != null	 * @invar   Each owning registered in the referenced list is	 *          effective and not yet terminated.	 *        | for each owning in ownings:	 *        |   ( (owning != null) && (!owning.isTerminated()) )	 */	private final List<Ownable> ownings = new ArrayList<Ownable>();	/**	 * Return the total value of all things owned by this person.	 *	 * @return  The sum of all the values of all things owned by this person.	 *        | result ==	 *        |   sum({owning in getAllOwnings() : owning.getValue()})	 * @throws  IllegalStateException	 *          This person is already terminated.	 *        | isTerminated()	 */	public BigInteger getTotalValue() throws IllegalStateException {		if (isTerminated())			throw new IllegalStateException("Person already terminated!");		BigInteger totalValue = BigInteger.ZERO;		for (Ownable owning : ownings)			totalValue = totalValue.add(owning.getValue());		return totalValue;	}	// The methods listed below illustrate different concepts offered in Java	// to retrieve information concerning the class to which an object belongs.	// None of the concepts is superior, meaning that each of the methods	// can be worked out just as well using the other concepts.	// In general, one must be very careful to use these concepts. As it will	// be discussed in later sessions, explicitly asking for the class to which	// an object belongs sometimes has a negative impact on the adaptability	// of software systems.	/**	 * Return the total amount of food needed to feed all dogs	 * owned by this person during the given number of days.	 *	 * @param   days	 *          The given number of days.	 * @return  The total amount of food needed to feed all dogs	 *          owned by this person during the given number of days.	 *        | let	 *        |   myDogs = set(dog: Dog | hasAsOwning(dog))	 *        | in	 *        |   result == sum({dog in myDogs : dog.getFoodAmount()})*days	 * @throws  IllegalStateException	 *          This person is already terminated.	 *        | isTerminated()	 * @throws  IllegalArgumentException	 *          The given number of days is negative.	 *        | days < 0	 */	public BigInteger getTotalFoodAmount(int days)			throws IllegalArgumentException, IllegalStateException {		if (isTerminated())			throw new IllegalStateException("Person already terminated!");		if (days < 0)			throw new IllegalArgumentException("Negative number of days!");		BigInteger totalDailyAmount = BigInteger.ZERO;		for (Ownable owning : ownings)			try {				// At this point, we use a type cast to verify whether the given owning				// is a dog. A ClassCastException is thrown, if the given owning turns				// out not to be dog (or an instance of a subclass of Dog).				Dog currentDog = (Dog) owning;				BigInteger currentDailyFoodAmount = BigInteger						.valueOf(currentDog.getDailyFoodAmount());				totalDailyAmount = totalDailyAmount.add(currentDailyFoodAmount);			} catch (ClassCastException exc) {				assert (!(owning instanceof Dog));			}		return totalDailyAmount.multiply(BigInteger.valueOf(days));	}	/**	 * Return the car with the largest motor volume owned by this person.	 *	 * @return  The resulting car is owned by this person.	 *        | hasAsOwning(result)	 * @return  No other car owned by this person has a higher motor volume	 *          than the resulting car	 *        | for each car in Car:	 *        |   if (hasAsOwning(car))	 *        |     then result.getMotorVolume() >= car.getMotorVolume()	 * @throws  IllegalStateException	 *          This person is already terminated.	 *        | isTerminated()	 * @throws  NoSuchElementException	 *          This person does not own any car.	 *        | for each car in Car: (! hasAsOwning(car)) )	 */	public Car getMostPowerfulCar() throws NoSuchElementException,			IllegalStateException {		if (isTerminated())			throw new IllegalStateException("Person already terminated!");		Car result = null;		for (Ownable owning : ownings)			// At this point, we use the operator instanceof, which checks whether the			// object at its left-hand side belongs to the class at its right-hand side.			// The null reference does not belong to any class, and an object of a class			// is also an instance of its superclass.			if (owning instanceof Car) {				Car currentCar = (Car) owning;				if ((result == null)						|| (result.getMotorVolume() < currentCar								.getMotorVolume()))					result = currentCar;			}		if (result == null)			throw new NoSuchElementException("Person without cars!");		return result;	}	/**	 * Return a painting owned by this person and painted by the given painter.	 *	 * @param	painter	 *			The painter to search for.	 * @return	The resulting painting is owned by this person and painted	 *			by the given painter.	 *        |    hasAsOwning(result)	 *        | && (result.getPainter() == painter)	 * @throws	IllegalStateException	 * 			This person is already terminated.	 *        | isTerminated()	 * @throws	NoSuchElementException	 *			This person does not own a painting by the given painter.	 *        | for each painting in Painting:	 *        |   (painting.getPainter() != painter) ||	 *        |   (! hasAsOwning(painting)) )	 */	public Painting getPaintingBy(Person painter)			throws NoSuchElementException, IllegalStateException {		if (isTerminated())			throw new IllegalStateException("Person already terminated!");		for (Ownable owning : ownings) {			// At this point, we use some facilities of reflection offered by Java.			// In Java, classes themselves are objects of the predefined class Class.			// The expression ClassName.class returns a reference to the object representing			// that class; the method getClass() returns a reference to the class to			// which the given object belongs.			// In this version it is important to use the method isAssignableFrom. If we			// had just written ==, an object of a subclass of the class Painting would not			// be taken into account then.			if (Painting.class.isAssignableFrom(owning.getClass())) {				Painting currentPainting = (Painting) owning;				if (currentPainting.getPainter() == painter)					return currentPainting;			}		}		throw new NoSuchElementException(				"Person without paintings of given painter!");	}	// The methods below offer more general instruments to compute totals	// for all the ownings of a person. The first approach uses an object	// that acts as a filter over all ownings. The second approach uses	// a method to be invoked against all ownings.	// In a future version of Java, these facilities will be supported in	// a better way by means of so-called higher-order functions (i.e.	// facilities to supply functions as arguments of methods), complemented	// with function literals and closures (instruments to define anonymous	// functions appealing to data defined in their context).	/**	 * Return the total value of all the things owned by this	 * person using the given extractor.	 *	 * @param   extractor	 *          The extractor to be used in evaluating all ownings of this person.	 * @return  The total amount returned by applying the given	 *          extractor to all things owned by this person.	 *        | result ==	 *        |   sum({ owning in getAllOwnings() : extractor.getValueFor(owning)})	 * @throws  IllegalStateException	 *          This person is already terminated.	 *        | isTerminated()	 * @throws  IllegalArgumentException	 *          The given extractor is not effective.	 *        | extractor == null	 */	public BigInteger getTotalFor(filters.BigIntegerExtractor extractor)			throws IllegalArgumentException, IllegalStateException {		if (extractor == null)			throw new IllegalArgumentException("Non-effective extractor!");		if (isTerminated())			throw new IllegalStateException("Person already terminated!");		BigInteger total = BigInteger.ZERO;		for (Ownable owning : ownings)			total = total.add(extractor.getValueFor(owning));		return total;	}	/**	 * Return the total of the results of invoking the given inspector	 * against all ownings of this person.	 *	 * @param   inspector	 *          The inspector to be invoked against all ownings of this person.	 * @return  The sum of all integer values returned by applying the given	 *          inspector to all things owned by this person. All invocations	 *          of the inspector resulting in an exception are discarded.	 *        | ...	 * @throws  IllegalStateException	 *          This person is already terminated.	 *        | isTerminated()	 */	public BigInteger getTotalFrom(Method inspector)			throws IllegalStateException {		if (isTerminated())			throw new IllegalStateException("Person already terminated!");		BigInteger total = BigInteger.ZERO;		for (Ownable owning : ownings)			try {				total = total.add(BigInteger.valueOf((Integer) inspector						.invoke(owning)));			} catch (Exception exc) {				// The invocation of the inspector against the current				// owning did not yield an integer value.			}		return total;	}}